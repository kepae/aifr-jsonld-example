{
  "@context": {
    "schema": "https://schema.org/",
    // Temporary namespace until ready to host the vocabulary with as few terms as needed.
    // For a "valid" JSON-LD the namespace URL doesn't need to resolve - it just needs to be unique.
    "aifr": "https://ai-flaw-report-form.streamlit.app/namespace/",
    // We don't yet have a published vocabulary for terms unique to the AI Flaw Report domain.
    // As a workaround, use the most generic type on schema.org.
    // (One could look at schema:CreativeWork or schema:Report, too.)
    "aifr:AIFlawReport": {
      "@id": "aifr:AIFlawReport",
      "@type": "schema:Thing"
    },
    // This is the key relationship (report -> system) that we want to save.
    // For now, we'll locally-define the type. In the future, this can be hosted in the vocabulary.
    "aifr:aiSystem": {
      "@id": "aifr:aiSystem",
      "@type": "schema:SoftwareApplication",
      "@container": "@set"
    }
  },
  // A @type field is always needed. See above comment about types.
  "@type": "aifr:AIFlawReport",
  // An @id field is always needed -- but it doesn't need to resolve to a real URL.
  // Primarily, it must be unique.
  "@id": "https://ai-flaw-report-form.streamlit.app/reports/ef6fa01c-fccd-4430-b81f-d8953d3f70f0",
  // Inherited properties from schema:Thing (nearly applies to all items).
  "schema:name": "AI Flaw Report: GPT-3.5-Turbo",
  "schema:description": "adsfasdf",
  // ATTN! This is our locally-defined type in the special @context.
  // This is -- again -- a workaround since we do not have a published vocab,
  // but we still want to begin identifying this special, semantic relationship.
  // All of this data should come from a maintained dataset/knowledge base so
  // it can just be added in.
  "aifr:aiSystem": [
    {
      // Technically, adding this @type field here isn't needed since the property (aiSystem)
      // is defined in the context and this can be inferred. However, being explicit can be
      // more readable.
      "@type": "schema:SoftwareApplication",
      // !!!
      // This is the special sauce! This uniqely identifies the model in the web.
      // When someone gets this report, there is far less ambiguity. The reader
      // doesn't have to rely solely on parsing strings.
      // And, they get the pair of important information: the model and developer.
      // Other reports will have the _same_ info for developers, allowing much easier aggregation
      // (i.e. no manually mapping and collecting all "gpt-*" strings.
      "@id": "https://platform.openai.com/docs/models/gpt-3.5-turbo",
      "name": "GPT-3.5-Turbo",
      // A schema:SoftwareApplication is a schema:CreativeWork, which specifically relates the idea of a publisher.
      // In the future, it might be more apt to have a working notion of developer vs. deployer, but this will do for now.
      "publisher": {
        "@type": "schema:Organization",
        "@id": "https://openai.com/",
        "name": "OpenAI",
        "url": "https://openai.com/",
        // There is often more than one canonical(-ish) web presence for a developer.
        // This helps capture those.
        "sameAs": [
          "https://en.wikipedia.org/wiki/OpenAI",
          "https://www.crunchbase.com/organization/openai"
        ]
      }
    }
  ],
  "other arbitrary data": {
    "anything": "This is a JSON object - if you need to add other fields or business logic, readers will have no problem!"
  }
}
